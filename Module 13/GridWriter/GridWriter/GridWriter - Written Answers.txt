Question 1 - In the GridWriterProgram, the calls to GridWriter to add a new GridItem, the objects created are not specifically GridItems, but they are Circles and Rectangles, which extend the GridItem superclass. Additionally, in the GridWriter class, the display Method having being passed MyCircle and MyRectangle objects from the "Main" Program, does not invoke the containsPoint method from the super class. Instead, although it accepts the MyCircle and MyRectangle classes as being GridItem classes and allowable parameters, it uses the subclasses' methods. 

Question 2 - The 'x' and 'y' variables are within the subclass's scope when constructed. Because they have a protected status, they are able to be manipulated directly from the subclass. That is, the MyCircle and MyRectangle classes can utilize the 'x' and 'y' variable directly. Because they are not public, they cannot be accessed outside the class. And because they are not private, they are allowed to be used by the containsPoints method directly. 

Question 3 - When a GridItem object is specifically declared, the containsPoint DOES run. Since there are no dynamic constructors besides the one that the compiler gives us by default initializing the primitive variables to (in my case) X = 0, Y = 0. It only returns--again only when I specifically added a new GridItem, hereby named "gi,"-- ture when System.out.println(gi.containsPoint(0,0)); is called. 

Question 4 - It doesn't like it. As mentioned in Question 2 by accident, when they are changed to private, the compiler complains that the subclasses are stepping out of bounds and trying to access a private variable out of their scope. They can still access them via the accessor methods included in the superclass, but they need to change their containsMethod to reflect this change. They would also have to change the constructors by invoking the mutator method of the superclass as opposed to modifying the 'x' and 'y' variable directly. 

Question 5 - Because the getArea and containsPoints are there are staples, an Abtract class would make it easier by basically telling any subclass that they should have a logically-equivalent method to the concept of, in this case, an area of a method and whether or not the subclass contains a point based on their structure. Since it follows that any subclass of GridItems of a certain shape have specific area formulas and ways of determining whether or not they have a point (i.e. a Triangle class) inside them, we don't really need to declare them in the superclass. 

Question 6 - An interface would be even better than an Abtract class because you can only extend an abstract class once. What if we wanted to create a Square class from the Rectangle class? We wouldn't under an abstract class, but it wouldn't make sense since a Square IS a rectangle! One that has both the same length as it does width! Also would mean that the GridItem just declares the conceptual methods like getArea and containsPoint and calls it a day. It's up for the subclass to declare any needed variables and the logical methods. Less code, and the GridItemProgram would still run just fine. 